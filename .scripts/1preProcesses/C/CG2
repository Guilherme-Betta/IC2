# Importa as bibliotecas necessárias
import pandas as pd
import os
from datetime import datetime
import locale

# --- CONFIGURAÇÃO ---
caminho_da_pasta = input('Insira o caminho da Pasta:')
caminho_da_pasta = caminho_da_pasta.strip('"').replace('\\', '/')

# 1. Arquivo de ENTRADA (gerado pelo Power Query)
nome_do_arquivo_excel = 'dadosLargos.xlsx' 

# 2. Arquivo de SAÍDA (o novo Excel com várias planilhas)
nome_do_arquivo_final = 'dados_analiticos_graduais.xlsx'

# Monta os caminhos completos
caminho_completo_excel = os.path.join(caminho_da_pasta, nome_do_arquivo_excel)
caminho_final_excel = os.path.join(caminho_da_pasta, nome_do_arquivo_final)

# ============================================================================
# FUNÇÃO AUXILIAR: Converter data de "Out, 2016" para datetime
# ============================================================================
def converter_data_brasileira(data_str):
    """
    Converte string no formato "Out, 2016" para datetime.
    Retorna None se não conseguir converter.
    """
    if pd.isna(data_str):
        return None
    
    # Se já for datetime, retorna como está
    if isinstance(data_str, datetime):
        return data_str
    if isinstance(data_str, pd.Timestamp):
        return data_str.to_pydatetime()
    
    # Mapeamento de meses em português para números
    meses_pt = {
        'jan': 1, 'fev': 2, 'mar': 3, 'abr': 4, 'mai': 5, 'jun': 6,
        'jul': 7, 'ago': 8, 'set': 9, 'out': 10, 'nov': 11, 'dez': 12
    }
    
    try:
        # Remove espaços extras, pontos e divide por vírgula
        data_limpa = str(data_str).strip().replace('.', '')
        partes = data_limpa.split(',')
        
        if len(partes) != 2:
            return None
        
        mes_str = partes[0].strip().lower()[:3]  # Pega primeiras 3 letras
        ano_str = partes[1].strip()
        
        if mes_str in meses_pt and ano_str.isdigit():
            mes = meses_pt[mes_str]
            ano = int(ano_str)
            # Cria data no primeiro dia do mês
            return datetime(ano, mes, 1)
        else:
            return None
    except Exception as e:
        return None

# ============================================================================
# ETAPA 0: CARREGAR TODAS AS PLANILHAS DO EXCEL
# ============================================================================
print(f"Iniciando a leitura de todas as planilhas do arquivo: {caminho_completo_excel}")

try:
    # Lê todas as planilhas do Excel
    excel_file = pd.ExcelFile(caminho_completo_excel)
    nomes_planilhas = excel_file.sheet_names
    print(f"\nPlanilhas encontradas: {nomes_planilhas}")
    
except FileNotFoundError:
    print(f"Erro: O arquivo '{caminho_completo_excel}' não foi encontrado.")
    exit()
except Exception as e:
    print(f"Erro ao ler o arquivo: {e}")
    exit()

# Separa planilhas anuais da planilha de dados anuais
planilhas_anuais = []
planilha_dados_anuais = None

for nome in nomes_planilhas:
    if nome.lower() == 'dadosanuais':
        planilha_dados_anuais = nome
    elif nome.isdigit() and len(nome) == 4:  # Verifica se é um ano (4 dígitos)
        planilhas_anuais.append(nome)

# Ordena as planilhas anuais cronologicamente
planilhas_anuais.sort()

print(f"\nPlanilhas anuais encontradas ({len(planilhas_anuais)}): {planilhas_anuais}")
if planilha_dados_anuais:
    print(f"Planilha de dados anuais: {planilha_dados_anuais}")

# ============================================================================
# ETAPA 1: CONCATENAR TODAS AS PLANILHAS ANUAIS
# ============================================================================
print("\n" + "="*60)
print("CONCATENANDO PLANILHAS ANUAIS")
print("="*60)

dataframes_anuais = []

for ano_planilha in planilhas_anuais:
    print(f"\nProcessando planilha do ano {ano_planilha}...")
    try:
        df_ano = pd.read_excel(caminho_completo_excel, sheet_name=ano_planilha)
        
        # Verifica se a primeira coluna é a coluna de data
        if len(df_ano.columns) == 0:
            print(f"  AVISO: Planilha {ano_planilha} está vazia. Pulando...")
            continue
        
        coluna_data = df_ano.columns[0]
        print(f"  - Coluna de data: '{coluna_data}'")
        print(f"  - Dimensões: {df_ano.shape[0]} linhas x {df_ano.shape[1]} colunas")
        
        # Converte a coluna de data para datetime
        print(f"  - Convertendo datas...")
        df_ano[coluna_data] = df_ano[coluna_data].apply(converter_data_brasileira)
        
        # DIAGNÓSTICO: Verifica quantas datas falharam na conversão
        linhas_antes = len(df_ano)
        datas_falhadas = df_ano[coluna_data].isna().sum()
        
        if datas_falhadas > 0:
            print(f"  - AVISO: {datas_falhadas} datas não puderam ser convertidas!")
            # Mostra exemplos de datas que falharam
            indices_falhados = df_ano[df_ano[coluna_data].isna()].index[:5]
            if len(indices_falhados) > 0:
                # Pega os valores originais antes da conversão
                df_ano_original = pd.read_excel(caminho_completo_excel, sheet_name=ano_planilha)
                print(f"  - Exemplos de datas que falharam:")
                for idx in indices_falhados:
                    if idx < len(df_ano_original):
                        valor_original = df_ano_original.iloc[idx, 0]
                        print(f"      Linha {idx+1}: '{valor_original}'")
        
        # Remove linhas onde a data não pôde ser convertida
        df_ano = df_ano.dropna(subset=[coluna_data])
        linhas_depois = len(df_ano)
        
        if linhas_antes != linhas_depois:
            print(f"  - AVISO: {linhas_antes - linhas_depois} linhas foram removidas devido a datas inválidas!")
        
        # Define a coluna de data como índice
        df_ano.set_index(coluna_data, inplace=True)
        
        # Remove colunas completamente vazias
        df_ano.dropna(axis=1, how='all', inplace=True)
        
        print(f"  - Após processamento: {df_ano.shape[0]} linhas x {df_ano.shape[1]} colunas")
        print(f"  - Período: {df_ano.index.min()} até {df_ano.index.max()}")
        
        dataframes_anuais.append(df_ano)
        
    except Exception as e:
        print(f"  ERRO ao processar planilha {ano_planilha}: {e}")
        continue

if not dataframes_anuais:
    print("\nERRO: Nenhuma planilha anual foi processada com sucesso!")
    exit()

# Concatena todos os DataFrames anuais
print(f"\nConcatenando {len(dataframes_anuais)} planilhas anuais...")
df = pd.concat(dataframes_anuais, axis=0, sort=False)

# Ordena por data (índice)
df.sort_index(inplace=True)

print(f"\nDataFrame CONCATENADO tem {df.shape[0]} linhas e {df.shape[1]} colunas.")
print(f"Período total: {df.index.min()} até {df.index.max()}")

# ============================================================================
# ETAPA 2: PROCESSAR PLANILHA DE DADOS ANUAIS (SEPARADAMENTE)
# ============================================================================
df_dados_anuais = None
if planilha_dados_anuais:
    print("\n" + "="*60)
    print("PROCESSANDO PLANILHA DE DADOS ANUAIS")
    print("="*60)
    try:
        df_dados_anuais = pd.read_excel(caminho_completo_excel, sheet_name=planilha_dados_anuais)
        
        # Remove colunas completamente vazias
        df_dados_anuais.dropna(axis=1, how='all', inplace=True)
        
        # Se a primeira coluna for data, tenta converter
        if len(df_dados_anuais.columns) > 0:
            primeira_col = df_dados_anuais.columns[0]
            # Tenta converter se parecer com data
            if df_dados_anuais[primeira_col].dtype == 'object':
                df_dados_anuais[primeira_col] = df_dados_anuais[primeira_col].apply(converter_data_brasileira)
                df_dados_anuais = df_dados_anuais.dropna(subset=[primeira_col])
                df_dados_anuais.set_index(primeira_col, inplace=True)
        
        print(f"Planilha de dados anuais processada: {df_dados_anuais.shape[0]} linhas x {df_dados_anuais.shape[1]} colunas")
        
    except Exception as e:
        print(f"AVISO: Erro ao processar planilha de dados anuais: {e}")
        df_dados_anuais = None

# ============================================================================
# DIAGNÓSTICO (OPCIONAL)
# ============================================================================
EXECUTAR_DIAGNOSTICO = True

if EXECUTAR_DIAGNOSTICO:
    print("\n" + "="*60)
    print("EXECUTANDO DIAGNÓSTICO")
    print("="*60)
    
    print(f"\nTotal de linhas: {len(df)}")
    print(f"Total de colunas: {len(df.columns)}")
    print(f"\nPrimeiras 5 colunas: {list(df.columns[:5])}")
    print(f"\nPrimeiras 3 linhas:")
    print(df.head(3))
    
    print(f"\n{'='*60}")
    print("Colunas que começam tardiamente (vazias nas primeiras 10%):")
    print(f"{'='*60}")
    primeiras_linhas = max(1, int(len(df) * 0.10))
    colunas_tardias_diag = []
    for col in df.columns:
        faltantes = df[col].head(primeiras_linhas).isnull().sum()
        if faltantes == primeiras_linhas:
            primeira_data = df[col].first_valid_index()
            colunas_tardias_diag.append(col)
            print(f"  - {col}: começa em {primeira_data}")
    
    if not colunas_tardias_diag:
        print("  Nenhuma coluna identificada como tardia.")
    else:
        print(f"\nTotal de colunas tardias encontradas: {len(colunas_tardias_diag)}")
    
    print(f"\n{'='*60}\n")

# ============================================================================
# ETAPA 3: IDENTIFICAR VARIÁVEIS 'CORE' E 'TARDIAS'
# ============================================================================
print("\n" + "="*60)
print("IDENTIFICANDO VARIÁVEIS 'CORE' E 'TARDIAS'")
print("="*60)

limiar_inicio_vazio = 0.10
linhas_iniciais_para_checar = max(1, int(len(df) * limiar_inicio_vazio))
df_inicio = df.head(linhas_iniciais_para_checar)

# Identifica colunas que estão COMPLETAMENTE vazias nas primeiras linhas
colunas_tardias_lista = list(df_inicio.columns[df_inicio.isnull().all()])
colunas_core_lista = [col for col in df.columns if col not in colunas_tardias_lista]

print(f"  - Verificando primeiras {linhas_iniciais_para_checar} linhas de {len(df)} totais")
print(f"  - {len(colunas_core_lista)} Variáveis 'Core' identificadas.")
print(f"  - {len(colunas_tardias_lista)} Variáveis 'Tardias' identificadas.")

if colunas_tardias_lista:
    if len(colunas_tardias_lista) > 5:
        print(f"  - Variáveis Tardias (primeiras 5): {colunas_tardias_lista[:5]}")
    else:
        print(f"  - Variáveis Tardias: {colunas_tardias_lista}")

# ============================================================================
# ETAPA 4: MAPEAMENTO CRONOLÓGICO E GERAÇÃO DE PLANILHAS
# ============================================================================
print("\n" + "="*60)
print("GERANDO ARQUIVO EXCEL COM PLANILHAS GRADUAIS")
print("="*60)

# Sempre salvar em novo arquivo: adiciona timestamp ao nome para evitar sobrescrita.
output_path = os.path.abspath(caminho_final_excel)
base, ext = os.path.splitext(output_path)
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
caminho_final_excel_usar = f"{base}_{timestamp}{ext}"
print(f"\n  - Salvando sempre em novo arquivo: '{caminho_final_excel_usar}'")

with pd.ExcelWriter(caminho_final_excel_usar, engine='openpyxl') as writer:
    
    # 1. Escreve a planilha com os dados 'Core'
    df_core = df[colunas_core_lista].copy()
    df_core.dropna(how='all', inplace=True)  # Remove linhas completamente vazias
    
    if not df_core.empty:
        df_core.to_excel(writer, sheet_name='dados_core', index=True)
        print(f"\n  - Planilha 'dados_core' criada com {df_core.shape[1]} variáveis e {df_core.shape[0]} linhas.")
        print(f"    (Dados de {df_core.index[0]} até {df_core.index[-1]})")
    else:
        print("\n  - AVISO: Planilha 'dados_core' está vazia.")
    
    # 2. Cria planilhas incrementais para variáveis tardias
    if colunas_tardias_lista:
        # Mapeia datas de início de cada variável tardia
        datas_de_inicio = {}
        for col in colunas_tardias_lista:
            primeira_data_valida = df[col].first_valid_index()
            if primeira_data_valida is not None:
                if primeira_data_valida not in datas_de_inicio:
                    datas_de_inicio[primeira_data_valida] = []
                datas_de_inicio[primeira_data_valida].append(col)
        
        # Ordena as datas de início
        datas_ordenadas = sorted(datas_de_inicio.keys())
        
        print(f"\n  - Encontradas {len(datas_ordenadas)} datas distintas de introdução de variáveis:")
        for data in datas_ordenadas[:10]:  # Mostrar primeiras 10
            print(f"    * {data}: {len(datas_de_inicio[data])} variáveis")
        
        # Loop para criar as planilhas incrementais
        colunas_acumuladas = colunas_core_lista.copy()
        
        for data_inicio in datas_ordenadas:
            novas_colunas_na_onda = datas_de_inicio[data_inicio]
            colunas_acumuladas.extend(novas_colunas_na_onda)
            
            # Formata a data para um nome de planilha válido e legível
            nome_planilha = f"a_partir_de_{data_inicio.strftime('%Y_%m')}"
            if len(nome_planilha) > 31:
                nome_planilha = f"desde_{data_inicio.strftime('%Y%m')}"
            
            # Cria o DataFrame para a planilha, fatiando a partir da data de início
            df_planilha = df.loc[data_inicio:][colunas_acumuladas].copy()
            
            # Remove apenas linhas completamente vazias
            df_planilha.dropna(how='all', inplace=True)
            
            # Verificar se não está vazia
            if df_planilha.empty:
                print(f"  - AVISO: Planilha '{nome_planilha}' está vazia e será pulada.")
                continue
            
            df_planilha.to_excel(writer, sheet_name=nome_planilha, index=True)
            print(f"  - Planilha '{nome_planilha}' criada com {df_planilha.shape[1]} variáveis e {df_planilha.shape[0]} linhas.")
            print(f"    (Dados de {df_planilha.index[0]} até {df_planilha.index[-1]})")
    
    # 3. Adiciona planilha de dados anuais (se existir)
    if df_dados_anuais is not None and not df_dados_anuais.empty:
        df_dados_anuais.to_excel(writer, sheet_name='dados_anuais', index=True)
        print(f"\n  - Planilha 'dados_anuais' criada com {df_dados_anuais.shape[1]} variáveis e {df_dados_anuais.shape[0]} linhas.")

print(f"\n{'='*60}")
if caminho_final_excel_usar != os.path.abspath(caminho_final_excel):
    print(f"Sucesso! O arquivo final foi salvo em '{caminho_final_excel_usar}'")
else:
    print(f"Sucesso! O arquivo final foi salvo em '{caminho_final_excel}'")
print(f"{'='*60}")